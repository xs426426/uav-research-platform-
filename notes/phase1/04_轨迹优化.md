# 04. Minimum Snap 轨迹优化

## 一、为什么需要轨迹优化

### 路径规划的输出

```
A* 或 RRT* 输出的是什么？

  ●───●───●───●───●───●───●
  起点     路径点（waypoints）   终点

这是一系列离散的点，连接起来是折线
```

### 折线路径的问题

```
┌─────────────────────────────────────────────────────────────────────────┐
│  问题 1：速度不连续                                                     │
│                                                                         │
│    ●───────●                                                            │
│             ╲                                                           │
│              ●                                                          │
│                                                                         │
│    在拐角处，速度方向瞬间改变                                           │
│    理论上需要无穷大的加速度！                                           │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│  问题 2：加速度不连续                                                   │
│                                                                         │
│    即使用圆弧连接，加速度也可能突变                                     │
│    突变的加速度 → 力突变 → 机械冲击 → 不稳定                           │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│  问题 3：无法直接执行                                                   │
│                                                                         │
│    飞控需要连续的位置/速度/加速度指令                                   │
│    离散点无法满足控制需求                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 轨迹优化的目标

```
把离散路径点转化为：

  平滑的曲线轨迹 + 时间参数

            ╭──────╮
           ╱        ╲
  ●───────●          ●───────●
  起点              终点

特点：
- 位置连续
- 速度连续
- 加速度连续
- 甚至更高阶导数连续
```

## 二、为什么叫 Minimum Snap

### 四旋翼的微分平坦性

```
┌─────────────────────────────────────────────────────────────────────────┐
│  四旋翼是"微分平坦"系统                                                 │
│                                                                         │
│  意思是：                                                               │
│  - 给定位置轨迹 p(t) = [x(t), y(t), z(t)]                              │
│  - 可以直接计算出所有控制输入                                           │
│                                                                         │
│  具体来说：                                                             │
│                                                                         │
│  位置 p(t)                                                              │
│    │                                                                    │
│    ├─ 一阶导数 → 速度 v(t)                                             │
│    │                                                                    │
│    ├─ 二阶导数 → 加速度 a(t) → 与推力相关                              │
│    │                                                                    │
│    ├─ 三阶导数 → jerk j(t)                                             │
│    │                                                                    │
│    └─ 四阶导数 → snap s(t) → 与电机转速变化率相关                      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 为什么最小化 Snap

```
┌─────────────────────────────────────────────────────────────────────────┐
│  Snap = 位置的四阶导数                                                  │
│                                                                         │
│  Snap 与什么相关？                                                      │
│                                                                         │
│  推力 = 质量 × 加速度                                                   │
│  推力变化率 ∝ jerk（三阶导数）                                          │
│  电机转速变化率 ∝ snap（四阶导数）                                      │
│                                                                         │
│  最小化 Snap 的好处：                                                   │
│  ✓ 电机转速变化平缓 → 省电                                             │
│  ✓ 机械应力小 → 结构安全                                               │
│  ✓ 控制输入平滑 → 飞行稳定                                             │
│  ✓ 自动保证位置、速度、加速度、jerk 连续                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 三、数学原理

### 多项式轨迹

```
┌─────────────────────────────────────────────────────────────────────────┐
│  用多项式表示一段轨迹                                                   │
│                                                                         │
│  为什么用多项式？                                                       │
│  - 求导容易（得到速度、加速度等）                                       │
│  - 计算方便                                                             │
│  - 可以精确通过指定点                                                   │
│                                                                         │
│  N 阶多项式：                                                           │
│                                                                         │
│  p(t) = c₀ + c₁t + c₂t² + c₃t³ + ... + cₙtⁿ                            │
│                                                                         │
│  其中 c₀, c₁, ..., cₙ 是待求的系数                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 为什么用 7 阶多项式

```
对于 Minimum Snap 问题：

我们要最小化 snap（四阶导数）的积分

在每段轨迹的两端，我们需要约束：
  - 位置（0 阶）
  - 速度（1 阶）
  - 加速度（2 阶）
  - jerk（3 阶）

每端 4 个约束，两端共 8 个约束

7 阶多项式有 8 个系数（c₀ 到 c₇）
刚好可以满足 8 个约束！

  7 阶多项式：p(t) = c₀ + c₁t + c₂t² + c₃t³ + c₄t⁴ + c₅t⁵ + c₆t⁶ + c₇t⁷
                     └──────────────────────────────────────────────────┘
                                      8 个系数
```

### 各阶导数

```
位置:     p(t)  = c₀ + c₁t + c₂t² + c₃t³ + c₄t⁴ + c₅t⁵ + c₆t⁶ + c₇t⁷

速度:     p'(t) = c₁ + 2c₂t + 3c₃t² + 4c₄t³ + 5c₅t⁴ + 6c₆t⁵ + 7c₇t⁶

加速度:   p''(t) = 2c₂ + 6c₃t + 12c₄t² + 20c₅t³ + 30c₆t⁴ + 42c₇t⁵

jerk:     p'''(t) = 6c₃ + 24c₄t + 60c₅t² + 120c₆t³ + 210c₇t⁴

snap:     p''''(t) = 24c₄ + 120c₅t + 360c₆t² + 840c₇t³
```

## 四、优化问题形式

### 目标函数

```
┌─────────────────────────────────────────────────────────────────────────┐
│  最小化 snap 的平方积分                                                 │
│                                                                         │
│           T                                                             │
│  J = ∫    [p''''(t)]² dt                                               │
│           0                                                             │
│                                                                         │
│  如果有多段轨迹（K 段）：                                               │
│                                                                         │
│       K    Tₖ                                                           │
│  J = Σ   ∫    [pₖ''''(t)]² dt                                          │
│      k=1   0                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 约束条件

```
1. 起点约束：
   p(0) = 起点位置
   p'(0) = 起点速度（通常为 0）
   p''(0) = 起点加速度（通常为 0）
   p'''(0) = 起点 jerk（通常为 0）

2. 终点约束：
   p(T) = 终点位置
   p'(T) = 终点速度（通常为 0）
   p''(T) = 终点加速度（通常为 0）
   p'''(T) = 终点 jerk（通常为 0）

3. 中间路径点约束（如果有）：
   第 k 段终点位置 = 第 k+1 段起点位置

4. 连续性约束（段与段之间）：
   位置连续
   速度连续
   加速度连续
   jerk 连续
```

### 矩阵形式

```
┌─────────────────────────────────────────────────────────────────────────┐
│  转化为二次规划 (QP) 问题                                               │
│                                                                         │
│  目标：   minimize  c^T Q c                                             │
│                                                                         │
│  约束：   A_eq · c = b_eq   （等式约束：位置、连续性）                  │
│           A_ub · c ≤ b_ub   （不等式约束：走廊约束，可选）              │
│                                                                         │
│  其中：                                                                 │
│  c = [c₀, c₁, ..., c₇, c₀', c₁', ...]^T   （所有段的系数）            │
│  Q = Hessian 矩阵（由 snap 积分得到）                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 五、代码实现

### 单轴单段优化

```python
import numpy as np
from scipy.linalg import block_diag
from scipy.optimize import minimize

class MinimumSnapTrajectory:
    """Minimum Snap 轨迹优化"""

    def __init__(self, waypoints, times):
        """
        参数:
            waypoints: 路径点列表 [(x,y,z), ...]
            times: 每段的时间分配 [T1, T2, ...]
        """
        self.waypoints = np.array(waypoints)
        self.times = np.array(times)
        self.n_segments = len(times)
        self.poly_order = 7  # 7 阶多项式

    def _compute_Q_matrix(self, T):
        """
        计算单段的 Hessian 矩阵 Q

        Q 来自于 snap 平方积分：∫[p''''(t)]² dt

        参数:
            T: 该段的时间
        """
        n = self.poly_order + 1  # 8 个系数
        Q = np.zeros((n, n))

        # snap 是四阶导数，从 c₄ 开始有贡献
        for i in range(4, n):
            for j in range(4, n):
                # 计算系数
                # d⁴/dt⁴(t^i) = i(i-1)(i-2)(i-3) t^(i-4)
                coef_i = np.math.factorial(i) / np.math.factorial(i-4)
                coef_j = np.math.factorial(j) / np.math.factorial(j-4)

                # 积分 ∫₀^T t^(i-4) * t^(j-4) dt = T^(i+j-7) / (i+j-7)
                power = i + j - 7
                Q[i, j] = coef_i * coef_j * (T ** power) / power

        return Q

    def _get_poly_value(self, coeffs, t, derivative=0):
        """
        计算多项式在 t 时刻的值（或其导数）

        参数:
            coeffs: 多项式系数 [c₀, c₁, ..., c₇]
            t: 时间
            derivative: 求几阶导数（0=位置，1=速度，...）
        """
        n = len(coeffs)
        result = 0

        for i in range(derivative, n):
            # 第 i 次项的 derivative 阶导数
            coef = coeffs[i]
            for d in range(derivative):
                coef *= (i - d)
            result += coef * (t ** (i - derivative))

        return result

    def optimize(self):
        """
        执行优化

        返回:
            每段的多项式系数列表
        """
        # 对每个维度（x, y, z）分别优化
        all_coeffs = []

        for dim in range(3):
            waypoints_1d = self.waypoints[:, dim]
            coeffs = self._optimize_1d(waypoints_1d)
            all_coeffs.append(coeffs)

        return all_coeffs

    def _optimize_1d(self, waypoints):
        """单个维度的优化"""
        n = self.poly_order + 1  # 每段 8 个系数
        total_coeffs = n * self.n_segments

        # 构建大 Q 矩阵（对角块）
        Q_blocks = [self._compute_Q_matrix(T) for T in self.times]
        Q = block_diag(*Q_blocks)

        # 构建等式约束 Aeq * c = beq
        Aeq, beq = self._build_equality_constraints(waypoints)

        # 使用二次规划求解
        # minimize 0.5 * c^T Q c
        # subject to Aeq * c = beq

        from scipy.optimize import minimize

        def objective(c):
            return 0.5 * c @ Q @ c

        def objective_grad(c):
            return Q @ c

        # 初始猜测
        c0 = np.zeros(total_coeffs)

        # 等式约束
        constraints = {'type': 'eq', 'fun': lambda c: Aeq @ c - beq}

        result = minimize(
            objective, c0,
            method='SLSQP',
            jac=objective_grad,
            constraints=constraints
        )

        # 整理结果
        coeffs = result.x.reshape(self.n_segments, n)
        return coeffs

    def _build_equality_constraints(self, waypoints):
        """构建等式约束"""
        n = self.poly_order + 1
        constraints = []
        values = []

        # 1. 起点约束（位置、速度、加速度、jerk）
        for deriv in range(4):
            row = np.zeros(n * self.n_segments)
            row[:n] = self._poly_coeff_at_t(0, deriv)
            constraints.append(row)

            if deriv == 0:
                values.append(waypoints[0])
            else:
                values.append(0)  # 起点速度/加速度/jerk = 0

        # 2. 终点约束
        for deriv in range(4):
            row = np.zeros(n * self.n_segments)
            T = self.times[-1]
            row[-n:] = self._poly_coeff_at_t(T, deriv)
            constraints.append(row)

            if deriv == 0:
                values.append(waypoints[-1])
            else:
                values.append(0)

        # 3. 中间点位置约束 + 连续性约束
        for k in range(self.n_segments - 1):
            T = self.times[k]

            # 位置约束：第 k 段在 T 时刻 = waypoints[k+1]
            row = np.zeros(n * self.n_segments)
            row[k*n:(k+1)*n] = self._poly_coeff_at_t(T, 0)
            constraints.append(row)
            values.append(waypoints[k+1])

            # 连续性约束：第 k 段终点 = 第 k+1 段起点（各阶导数）
            for deriv in range(4):
                row = np.zeros(n * self.n_segments)
                # 第 k 段在 T 时刻
                row[k*n:(k+1)*n] = self._poly_coeff_at_t(T, deriv)
                # 减去第 k+1 段在 0 时刻
                row[(k+1)*n:(k+2)*n] = -self._poly_coeff_at_t(0, deriv)
                constraints.append(row)
                values.append(0)

        return np.array(constraints), np.array(values)

    def _poly_coeff_at_t(self, t, derivative):
        """
        获取多项式在 t 时刻的系数向量

        例如 p(t) = c₀ + c₁t + c₂t² + ...
        在 t=2 时，系数向量 = [1, 2, 4, 8, ...]
        """
        n = self.poly_order + 1
        coeffs = np.zeros(n)

        for i in range(derivative, n):
            coef = 1
            for d in range(derivative):
                coef *= (i - d)
            coeffs[i] = coef * (t ** (i - derivative))

        return coeffs

    def evaluate(self, t_query):
        """
        计算给定时间的位置

        参数:
            t_query: 查询时间
        """
        # 确定在哪一段
        cumsum = np.cumsum([0] + list(self.times))

        for k in range(self.n_segments):
            if t_query <= cumsum[k+1]:
                local_t = t_query - cumsum[k]
                break
        else:
            k = self.n_segments - 1
            local_t = self.times[-1]

        # 计算位置
        pos = np.zeros(3)
        for dim in range(3):
            coeffs = self.all_coeffs[dim][k]
            pos[dim] = self._get_poly_value(coeffs, local_t, 0)

        return pos
```

## 六、时间分配

### 为什么时间分配重要

```
┌─────────────────────────────────────────────────────────────────────────┐
│  时间分配 = 给每段轨迹分配多少时间                                      │
│                                                                         │
│  问题：                                                                 │
│  ●────────────●────●                                                   │
│     长段          短段                                                  │
│                                                                         │
│  如果时间分配不合理：                                                   │
│  - 长段时间太短 → 速度太快，不安全                                     │
│  - 短段时间太长 → 浪费时间，效率低                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 常用时间分配策略

```python
def allocate_time(waypoints, method='trapezoidal', v_max=2.0, a_max=1.0):
    """
    时间分配

    参数:
        waypoints: 路径点列表
        method: 分配方法
        v_max: 最大速度
        a_max: 最大加速度
    """
    waypoints = np.array(waypoints)
    n_segments = len(waypoints) - 1
    times = []

    for i in range(n_segments):
        dist = np.linalg.norm(waypoints[i+1] - waypoints[i])

        if method == 'uniform':
            # 方法 1：均匀分配（按距离比例）
            T = dist / v_max

        elif method == 'trapezoidal':
            # 方法 2：梯形速度曲线
            # 加速段 + 匀速段 + 减速段
            t_acc = v_max / a_max  # 加速时间
            d_acc = 0.5 * a_max * t_acc**2  # 加速距离

            if dist < 2 * d_acc:
                # 距离太短，无法达到最大速度
                T = 2 * np.sqrt(dist / a_max)
            else:
                # 有匀速段
                d_const = dist - 2 * d_acc
                t_const = d_const / v_max
                T = 2 * t_acc + t_const

        times.append(T)

    return times
```

## 七、轨迹效果

```
优化前（折线路径）：

  ●─────────●
            │
            │
            ●─────────●

优化后（平滑曲线）：

  ●─────────╮
             ╲
              ╲
               ╰─────────●

特点：
- 在拐角处平滑过渡
- 速度、加速度连续
- 可以直接发送给飞控执行
```

## 八、实际应用注意事项

```
┌─────────────────────────────────────────────────────────────────────────┐
│  1. 安全走廊约束                                                        │
│     - 平滑后的轨迹可能偏离原路径点                                      │
│     - 需要添加走廊约束确保不碰撞                                        │
│                                                                         │
│  2. 动力学约束                                                          │
│     - 添加最大速度/加速度约束                                           │
│     - 使轨迹可执行                                                      │
│                                                                         │
│  3. 数值稳定性                                                          │
│     - 时间归一化（每段映射到 [0,1]）                                   │
│     - 避免数值精度问题                                                  │
│                                                                         │
│  4. 在线重规划                                                          │
│     - 当遇到新障碍物时需要重新规划                                      │
│     - 计算速度是关键                                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 九、总结

```
Minimum Snap 轨迹优化核心要点：

1. 目标：最小化 snap（四阶导数）
   └── 保证电机平滑、飞行稳定

2. 方法：7 阶多项式 + QP 求解
   └── 8 个系数满足 8 个约束

3. 约束：
   ├── 起点/终点状态
   ├── 中间点位置
   └── 段间连续性

4. 结果：
   ├── 位置连续
   ├── 速度连续
   ├── 加速度连续
   └── jerk 连续

5. 完整流程：
   路径点 → 时间分配 → QP 优化 → 平滑轨迹
```
