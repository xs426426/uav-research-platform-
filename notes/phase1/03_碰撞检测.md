# 03. 碰撞检测

## 一、为什么需要碰撞检测

```
路径规划的核心约束：路径不能穿过障碍物

无论是 A* 还是 RRT，都需要回答一个问题：
  "从点 A 到点 B 的路径是否安全？"

这就是碰撞检测要解决的问题。
```

## 二、碰撞检测的层次

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      碰撞检测的三个层次                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 点检测                                                              │
│     └── 这个点是否在障碍物内？                                          │
│                                                                         │
│  2. 线段检测                                                            │
│     └── 从 A 到 B 的线段是否穿过障碍物？                                │
│                                                                         │
│  3. 体积检测                                                            │
│     └── 无人机（有体积）是否与障碍物碰撞？                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 三、方法1：栅格地图检测

### 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│  栅格地图：把连续空间离散化为一个个小格子                               │
│                                                                         │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                                     │
│  │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 0 │ 0 │                                     │
│  ├───┼───┼───┼───┼───┼───┼───┼───┤     0 = 自由空间                    │
│  │ 0 │ 0 │ 0 │ 1 │ 1 │ 0 │ 0 │ 0 │     1 = 障碍物                      │
│  ├───┼───┼───┼───┼───┼───┼───┼───┤                                     │
│  │ 0 │ 0 │ 0 │ 1 │ 1 │ 1 │ 0 │ 0 │                                     │
│  ├───┼───┼───┼───┼───┼───┼───┼───┤                                     │
│  │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │ 0 │                                     │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                                     │
│                                                                         │
│  点检测：直接查表 grid[x][y][z]                                         │
│  时间复杂度：O(1)                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

### 代码实现

```python
class GridMapCollisionChecker:
    """栅格地图碰撞检测"""

    def __init__(self, grid, resolution=0.5, origin=(0, 0, 0)):
        """
        参数:
            grid: 3D numpy 数组，0=自由，1=障碍
            resolution: 每个格子的实际尺寸（米）
            origin: 地图原点在世界坐标系中的位置
        """
        self.grid = grid
        self.resolution = resolution
        self.origin = np.array(origin)

    def world_to_grid(self, world_pos):
        """世界坐标转栅格索引"""
        grid_pos = (np.array(world_pos) - self.origin) / self.resolution
        return tuple(int(p) for p in grid_pos)

    def is_collision(self, world_pos):
        """
        检测点是否碰撞

        参数:
            world_pos: 世界坐标 (x, y, z)

        返回:
            True = 碰撞, False = 安全
        """
        grid_pos = self.world_to_grid(world_pos)

        # 检查边界
        for i, p in enumerate(grid_pos):
            if p < 0 or p >= self.grid.shape[i]:
                return True  # 超出边界视为碰撞

        # 查表
        return self.grid[grid_pos] == 1

    def is_path_collision(self, start, end, check_resolution=0.1):
        """
        检测线段是否碰撞

        方法：沿线段采样多个点，逐个检测

        参数:
            start: 起点
            end: 终点
            check_resolution: 采样间隔（米）
        """
        start = np.array(start)
        end = np.array(end)

        distance = np.linalg.norm(end - start)
        n_checks = max(int(distance / check_resolution), 2)

        for i in range(n_checks + 1):
            t = i / n_checks  # 0 到 1 的插值参数
            point = start + t * (end - start)

            if self.is_collision(point):
                return True

        return False
```

### 线段检测图示

```
线段碰撞检测：沿线段采样检测

  起点                                         终点
   ●━━━━●━━━━●━━━━●━━━━●━━━━●━━━━●━━━━●━━━━●━━━━●
         ↑    ↑    ↑    ↑    ↑    ↑    ↑
       采样点：每隔 0.1m 检测一次

如果任意采样点碰撞 → 整条线段碰撞
```

## 四、方法2：AABB 包围盒检测

### 原理

```
AABB = Axis-Aligned Bounding Box = 轴对齐包围盒

┌─────────────────────────────────────────────────────────────────────────┐
│  思想：用一个与坐标轴对齐的长方体包围障碍物                             │
│                                                                         │
│        实际障碍物          AABB 包围盒                                  │
│                                                                         │
│          ╱╲                 ┌───────┐                                  │
│         ╱  ╲                │       │                                  │
│        ╱    ╲      →        │  ╱╲   │                                  │
│       ╱──────╲              │ ╱  ╲  │                                  │
│                             └───────┘                                   │
│                                                                         │
│  优点：检测非常快（只需比较坐标范围）                                   │
│  缺点：包围盒比实际障碍物大，可能误判                                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### AABB 碰撞检测

```
两个 AABB 是否相交：

  ┌───────┐
  │   A   │
  └───────┘
           ┌───────┐
           │   B   │
           └───────┘

相交条件（3D 情况）：
  在 X 轴上重叠 AND
  在 Y 轴上重叠 AND
  在 Z 轴上重叠

即：
  A.max_x >= B.min_x AND A.min_x <= B.max_x AND
  A.max_y >= B.min_y AND A.min_y <= B.max_y AND
  A.max_z >= B.min_z AND A.min_z <= B.max_z
```

### 代码实现

```python
class AABB:
    """轴对齐包围盒"""

    def __init__(self, min_point, max_point):
        """
        参数:
            min_point: 包围盒最小角 (x_min, y_min, z_min)
            max_point: 包围盒最大角 (x_max, y_max, z_max)
        """
        self.min_point = np.array(min_point)
        self.max_point = np.array(max_point)

    def contains_point(self, point):
        """检测点是否在包围盒内"""
        point = np.array(point)
        return np.all(point >= self.min_point) and np.all(point <= self.max_point)

    def intersects(self, other):
        """检测两个 AABB 是否相交"""
        return (np.all(self.max_point >= other.min_point) and
                np.all(self.min_point <= other.max_point))


class AABBCollisionChecker:
    """AABB 碰撞检测器"""

    def __init__(self, obstacles):
        """
        参数:
            obstacles: AABB 列表
        """
        self.obstacles = obstacles

    def is_collision(self, point):
        """检测点是否与任意障碍物碰撞"""
        for obs in self.obstacles:
            if obs.contains_point(point):
                return True
        return False

    def is_path_collision(self, start, end, drone_radius=0.3):
        """
        检测路径是否碰撞

        方法：将无人机建模为球体，检测沿路径扫过的胶囊体
              简化处理：沿路径采样 + 膨胀障碍物
        """
        # 沿路径采样检测
        start = np.array(start)
        end = np.array(end)

        distance = np.linalg.norm(end - start)
        n_checks = max(int(distance / 0.1), 2)

        for i in range(n_checks + 1):
            t = i / n_checks
            point = start + t * (end - start)

            # 检查点周围的球形区域
            for obs in self.obstacles:
                # 膨胀障碍物
                inflated = AABB(
                    obs.min_point - drone_radius,
                    obs.max_point + drone_radius
                )
                if inflated.contains_point(point):
                    return True

        return False
```

## 五、方法3：障碍物膨胀

### 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│  问题：无人机有体积，不是一个点                                         │
│                                                                         │
│  如果只检测中心点：                                                     │
│                                                                         │
│        无人机                                                           │
│         ╭───╮                                                           │
│         │ ● │  ← 中心点安全                                            │
│         ╰───╯                                                           │
│              ┌───────┐                                                  │
│              │障碍物 │                                                  │
│              └───────┘                                                  │
│         ↑                                                               │
│     但机身可能已经撞上了！                                              │
│                                                                         │
│  解决方案：障碍物膨胀                                                   │
│                                                                         │
│  原始障碍物            膨胀后                                           │
│  ┌───────┐          ╔═══════════╗                                      │
│  │障碍物 │    →     ║ ┌───────┐ ║    膨胀半径 = 无人机半径             │
│  └───────┘          ║ │障碍物 │ ║                                      │
│                     ║ └───────┘ ║                                      │
│                     ╚═══════════╝                                      │
│                                                                         │
│  膨胀后，只检测中心点就够了！                                           │
└─────────────────────────────────────────────────────────────────────────┘
```

### 栅格地图膨胀

```python
def inflate_grid(grid, inflation_radius, resolution):
    """
    膨胀栅格地图

    参数:
        grid: 原始栅格地图 (0=自由, 1=障碍)
        inflation_radius: 膨胀半径（米）
        resolution: 栅格分辨率（米）

    返回:
        膨胀后的栅格地图
    """
    import scipy.ndimage as ndimage

    # 计算膨胀的栅格数
    inflate_cells = int(np.ceil(inflation_radius / resolution))

    # 创建球形结构元素
    struct = create_sphere_struct(inflate_cells)

    # 使用形态学膨胀
    inflated = ndimage.binary_dilation(grid, structure=struct)

    return inflated.astype(np.int8)


def create_sphere_struct(radius):
    """创建球形结构元素"""
    size = 2 * radius + 1
    struct = np.zeros((size, size, size), dtype=bool)

    center = radius
    for x in range(size):
        for y in range(size):
            for z in range(size):
                dist = np.sqrt((x-center)**2 + (y-center)**2 + (z-center)**2)
                if dist <= radius:
                    struct[x, y, z] = True

    return struct
```

### 膨胀效果图示

```
原始地图（2D 简化）：            膨胀后：

  . . . . . . . . . .           . . . . . . . . . .
  . . . . . . . . . .           . . . . . . . . . .
  . . . . # # . . . .           . . # # # # # . . .
  . . . . # # . . . .    →      . . # # # # # . . .
  . . . . # # . . . .           . . # # # # # . . .
  . . . . . . . . . .           . . # # # # # . . .
  . . . . . . . . . .           . . . . . . . . . .

  # = 障碍物
  膨胀半径 = 1 格
```

## 六、方法4：距离场 (Distance Field)

### 原理

```
┌─────────────────────────────────────────────────────────────────────────┐
│  距离场：预计算每个点到最近障碍物的距离                                 │
│                                                                         │
│  栅格地图：                  距离场：                                   │
│                                                                         │
│  . . . # # .                 3 2 1 0 0 1                               │
│  . . . # # .        →        3 2 1 0 0 1                               │
│  . . . . . .                 2 2 1 1 1 1                               │
│  . . . . . .                 2 2 2 2 2 2                               │
│                                                                         │
│  数字 = 到最近障碍物的距离（格子数）                                    │
│                                                                         │
│  优点：                                                                 │
│  - 查询只需 O(1)                                                        │
│  - 可以快速判断"这里离障碍物多远"                                       │
│  - 支持连续查询（插值）                                                 │
│                                                                         │
│  缺点：                                                                 │
│  - 预计算需要时间                                                       │
│  - 占用额外内存                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 代码实现

```python
from scipy.ndimage import distance_transform_edt

class DistanceFieldChecker:
    """基于距离场的碰撞检测"""

    def __init__(self, grid, resolution=0.5):
        """
        参数:
            grid: 原始栅格地图 (0=自由, 1=障碍)
            resolution: 栅格分辨率
        """
        self.resolution = resolution

        # 计算距离场
        # distance_transform_edt: 计算每个 0 到最近 1 的欧几里得距离
        free_space = (grid == 0)
        self.distance_field = distance_transform_edt(free_space) * resolution

    def get_distance(self, world_pos):
        """获取点到最近障碍物的距离"""
        grid_pos = self._world_to_grid(world_pos)

        # 边界检查
        for i, p in enumerate(grid_pos):
            if p < 0 or p >= self.distance_field.shape[i]:
                return 0  # 边界外视为碰撞

        return self.distance_field[grid_pos]

    def is_collision(self, world_pos, safety_margin=0.3):
        """
        检测是否碰撞

        参数:
            world_pos: 世界坐标
            safety_margin: 安全距离（无人机半径）
        """
        distance = self.get_distance(world_pos)
        return distance < safety_margin

    def _world_to_grid(self, world_pos):
        """世界坐标转栅格索引"""
        return tuple(int(p / self.resolution) for p in world_pos)
```

## 七、碰撞检测优化

### 层次化检测

```
┌─────────────────────────────────────────────────────────────────────────┐
│  思想：先用简单检测排除大部分情况，再用精确检测                         │
│                                                                         │
│  粗检测（快）                精细检测（慢但准）                         │
│       │                           │                                     │
│       ▼                           ▼                                     │
│  ┌─────────┐   可能碰撞    ┌─────────────┐                             │
│  │  AABB   │  ──────────→  │ 精确几何体  │                             │
│  │  检测   │               │    检测     │                             │
│  └─────────┘               └─────────────┘                             │
│       │                                                                 │
│       │ 明确不碰撞                                                      │
│       ▼                                                                 │
│     安全 ✓                                                              │
│                                                                         │
│  大多数情况在粗检测就能排除，节省计算量                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

### 空间分割加速

```
问题：如果有 N 个障碍物，每次检测都要遍历所有？

解决：空间分割数据结构

┌─────────────────────────────────────────────────────────────────────────┐
│                         空间分割方法                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 八叉树 (Octree)                                                     │
│     - 递归地将空间分成 8 个子区域                                       │
│     - 只检测相关区域的障碍物                                            │
│     - 查询复杂度：O(log N)                                              │
│                                                                         │
│  2. KD 树 (KD-Tree)                                                     │
│     - 按维度交替分割空间                                                │
│     - 适合最近邻搜索                                                    │
│     - 查询复杂度：O(log N)                                              │
│                                                                         │
│  3. 均匀网格 (Uniform Grid)                                             │
│     - 将空间划分为固定大小的格子                                        │
│     - 每个格子存储其中的障碍物                                          │
│     - 查询复杂度：O(1)（只检查所在格子）                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 八、碰撞检测方法对比

```
┌──────────────────┬──────────────┬──────────────┬─────────────────────────┐
│      方法        │    速度      │    精度      │         适用场景        │
├──────────────────┼──────────────┼──────────────┼─────────────────────────┤
│    栅格地图      │  O(1) 查表   │   取决于分辨 │  结构化环境、室内       │
│                  │              │   率         │                         │
├──────────────────┼──────────────┼──────────────┼─────────────────────────┤
│      AABB        │    非常快    │   有误判     │  粗检测、规则障碍物     │
├──────────────────┼──────────────┼──────────────┼─────────────────────────┤
│    障碍物膨胀    │  预处理后快  │   保守（安全）│  需要安全裕度的场景     │
├──────────────────┼──────────────┼──────────────┼─────────────────────────┤
│     距离场       │   O(1)       │      高      │  需要距离信息的场景     │
│                  │              │              │  如 MPC 约束            │
└──────────────────┴──────────────┴──────────────┴─────────────────────────┘
```

## 九、实践建议

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         实践建议                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. 先膨胀后规划                                                        │
│     - 将障碍物膨胀无人机半径                                            │
│     - 规划时只检测中心点                                                │
│     - 简单且安全                                                        │
│                                                                         │
│  2. 选择合适的分辨率                                                    │
│     - 太粗：可能漏检                                                    │
│     - 太细：计算量大                                                    │
│     - 建议：无人机尺寸的 1/3 到 1/5                                     │
│                                                                         │
│  3. 线段检测的采样间隔                                                  │
│     - 应小于最小障碍物尺寸                                              │
│     - 通常 0.1m 足够                                                    │
│                                                                         │
│  4. 预留安全裕度                                                        │
│     - 考虑定位误差                                                      │
│     - 考虑控制延迟                                                      │
│     - 通常额外增加 10-20cm                                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

## 十、总结

```
碰撞检测核心要点：

1. 点检测 → 线段检测 → 体积检测
   └── 复杂度递增

2. 障碍物膨胀
   └── 将体积问题转化为点问题

3. 权衡速度与精度
   ├── 粗检测快但可能误判
   └── 精检测慢但准确

4. 预留安全裕度
   └── 考虑实际系统的不确定性
```
